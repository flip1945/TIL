# 보물 (Silver 4)

### 문제 설명

옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.

길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.

S = A\[0]×B\[0] + ... + A\[N-1]×B\[N-1]

S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.

S의 최솟값을 출력하는 프로그램을 작성하시오.

---

#### 입력

첫째 줄에 N이 주어진다. 둘째 줄에는 A에 있는 N개의 수가 순서대로 주어지고, 셋째 줄에는 B에 있는 수가 순서대로 주어진다. N은 50보다 작거나 같은 자연수이고, A와 B의 각 원소는 100보다 작거나 같은 음이 아닌 정수이다.

---

#### 출력

첫째 줄에 S의 최솟값을 출력한다.

---

#### 예제 입력 1

~~~
5
1 1 1 6 0
2 7 8 3 1
~~~

#### 예제 출력 1

~~~
18
~~~

출처 : https://www.acmicpc.net/problem/1026

---

### 문제풀이

저는 이 문제를 풀기 전에 완전 탐색문제리고 생각했습니다.

a배열의 순열을 b배열과 매치시켜서 정답을 찾는 문제라고 생각했는데,

n이 50이하의 숫자라서 배열의 순열을 구하게되면 최대값이 너무 크다는 것을 깨닫고 다른 방식으로 푸는 문제라는 것을 알았습니다.

a는 내림차순으로 정렬하고, b는 오름차순으로 정렬하면(a, b를 서로 반대로 정렬하기만 하면 됩니다.)

s의 값이 최소인 결과를 얻을 수 있습니다.

---

#### 나의 풀이

~~~python
n = int(input())
a = sorted(list(map(int, input().split())), reverse=True)
b = sorted(list(map(int, input().split())))

print(sum(a[i] * b[i] for i in range(n)))
~~~

---

#### 다른 사람의 풀이

출처 : https://www.acmicpc.net/source/9187996

~~~python
input()
print(sum(i*j for i, j in zip(sorted(map(int, input().split())), sorted(map(int, input().split()), reverse = True))))
~~~
