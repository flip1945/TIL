# 알파벳(Gold 5)

### 문제

세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다.   

말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다.   

좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다.   

---

#### 입력

첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1 ≤ R,C ≤ 20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다.

---

#### 출력

첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다.

---

#### 예제 입력 1
~~~
2 4
CAAB
ADCB
~~~

#### 예제 출력 1
~~~
3
~~~

#### 예제 입력 2
~~~
3 6
HFDFFB
AJHGDH
DGAGEH
~~~

#### 예제 출력 2
~~~
6
~~~

#### 예제 입력 3
~~~
5 5
IEFCJ
FHFKC
FFALF
HFGCF
HMCHH
~~~

#### 예제 출력 3
~~~
10
~~~

[출처](https://www.acmicpc.net/problem/1987)

---

### 문제풀이

이번 문제는 dfs 혹은 bfs로 풀 수 있는 문제입니다.   

저는 dfs로 문제를 풀었는데, dfs로 풀게되면 python3으로는 정답을 맞출 수 없고, pypy3로 제출해야합니다.   

하지만 bfs로 푼 문제들은 그냥 python3로 통과한 것을 보면 몇가지 차이점을 생각해볼 수 있습니다.   

저는 dfs로 문제를 풀 때, 거의 재귀를 사용합니다. (bfs로 풀 때는 반복문만 사용합니다.)   

그런데 다른 분들의 풀이를 보니 dfs로 풀어서 python3로 제출하신 분들은 재귀를 사용하지 않고, stack을 이용해 구현한 것을 알아낼 수 있었습니다.   

찾아보니 재귀를 이용하는 것보다 반복문을 이용한 것이 속도도 더 빠르고 메모리도 더 적게 사용하는 것을 알게됐습니다.   

재귀를 사용하는 이유는 1. 가독성이 더 좋을 경우 2. 변수 사용을 적게할 경우 2가지입니다.   

이런 문제를 풀 때는 stack을 이용해서 풀어봐야 겠습니다.   

bfs로 풀게 되면 반복문을 사용하기 때문에 이 문제를 쉽게 풀었겠지만 재귀가 반복문에 비해 훨씬 느리다는 것은 몰랐을 것 같습니다.   

---

#### 나의 풀이

~~~python
r, c = map(int, input().split())
board = [list(map(lambda x: ord(x)-65, input())) for _ in range(r)]
route = [0] * 26

def dfs(x, y, idx):
    global m
    m = max(m, idx)
    for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
        nx, ny = x + dx, y + dy
        if 0 <= nx < r and 0 <= ny < c and not route[board[nx][ny]]:
            route[board[nx][ny]] = 1
            dfs(nx, ny, idx + 1)
            route[board[nx][ny]] = 0

m = 1
route[board[0][0]] = 1
dfs(0, 0, 1)
print(m)
~~~

---

#### 다른 사람의 풀이

~~~python
m = [*open(0)]
r,c = map(int,m[0].split())
m = m[1:]
q = set()
q.add((0,0,m[0][0]))
z = 0
while q:
    a,b,s = q.pop()
    z = max(len(s), z)
    for i,j in ((1,0),(-1,0),(0,1),(0,-1)):
        if 0<=(x:=a+i)<r and 0<=(y:=b+j)<c:
            if m[x][y] not in s:
                q.add((x,y,s+m[x][y]))
print(z)
~~~
