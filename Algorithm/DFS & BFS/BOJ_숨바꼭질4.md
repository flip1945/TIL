# 숨바꼭질4(Gold 4)

### 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2\*X의 위치로 이동하게 된다.   

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.   

---

#### 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.   

---

#### 출력

첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.   

둘째 줄에 어떻게 이동해야 하는지 공백으로 구분해 출력한다.      

---

#### 예제 입력 1
~~~
5 17
~~~

#### 예제 출력 1
~~~
4
5 10 9 18 17
~~~

#### 예제 입력 2
~~~
5 17
~~~

#### 예제 출력 2
~~~
4
5 4 8 16 17
~~~

[출처](https://www.acmicpc.net/problem/13913)

---

### 문제풀이

이 문제는 bfs 문제입니다.   

이전에 풀었던 숨바꼭질 문제의 확장판인데, 이번에는 이동 경로를 표시해야 하는 문제입니다.  

처음 풀 때는 queue에 이동 경로 문자열을 넣어서 문제를 풀었습니다.   

그런데 시간 초과가 나왔습니다. pyhton에서 문자열 끼리 더할 때, O(n)이 걸리는 걸 처음 알게 됐습니다.   

그래서 queue에 저장할 때 리스트로 바꿔봤는데, 리스트는 call by reference라서 원하는 데로 구현할 수 없었습니다.   

리스트로 문자열과 비슷하게 구현은 해봤는데, 리스트끼리 더하는 연산도 O(n) 시간이 걸려서 시간 초과 판정을 받았습니다.   
이것도 이 때 처음 알게 됐습니다.

결국 문제를 해결한 방법은 경로 리스트를 만들고, 각 리스트에 바로 이전 경로만 저장하는 방식으로 문제를 해결했습니다.   

도착점에 도착했을 때, 저장된 이동 경로를 거슬러 올라가면 이동 경로를 알 수 있습니다.   

이번 문제는 생각할 거리도 많고 알게된 것도 많아서 재밌는 문제였습니다.   

---

#### 나의 풀이

~~~python
from collections import deque

n, k = map(int, input().split())
que = deque([(n)])
# 최단 시간을 저장할 리스트 생성
dp = [-1] * 100001
# 시작점의 최단 시간을 초기화
dp[n] = 0
# 경로 리스트를 생성
route = [[] for _ in range(100001)]
# bfs 실행
while que:
    cur = que.popleft()
    # 도착점에 도달할 경우
    if cur == k:
        # 최단 시간을 출력
        print(dp[cur])
        # 최단 경로를 거슬러 올라가서 파악
        result = [cur]
        end = route[cur]
        while len(end):
            result.append(end[0])
            end = route[end[0]]
        # 거슬러 올라간 경로를 뒤집어서 정답으로 출력
        print(*reversed(result))
        break
    # 걷기, 순간이동 하는 곳을 탐색
    for next in [cur - 1, cur + 1, cur * 2]:
        # 다음 이동 위치가 좌표를 벗어나지 않고, 처음 방문한 경우에만 실행
        if 0 <= next <= 100000 and dp[next] == -1:
            que.append(next)
            # 최단 시간 리스트를 갱신
            dp[next] = dp[cur] + 1
            # 경로 리스트를 갱신
            route[next].append(cur)
~~~
