# 숨바꼭질2(Gold 5)

### 문제

수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2\*X의 위치로 이동하게 된다.   

수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.   

---

#### 입력

첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.   

---

#### 출력

첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.   

둘째 줄에는 가장 빠른 시간으로 수빈이가 동생을 찾는 방법의 수를 출력한다.   

---

#### 예제 입력 1
~~~
5 17  
~~~

#### 예제 출력 1
~~~
4
2
~~~

[출처](https://www.acmicpc.net/problem/12851)

---

### 문제풀이

이 문제는 bfs 문제입니다.   

이전에 풀었던 숨바꼭질 문제의 확장판인데, 이번에는 최단 시간 뿐만아니라 최단 경로의 개수도 출력해야 합니다.    

이를 위해서 도착점에 도달했을 때, 바로 끝내지 않고 결과 리스트에 결과값을 저장하도록 했습니다.    

결과 리스트에 최단 시간과 최단 경로의 개수가 저장되기 때문에, 이를 이용해서 정답을 출력하면 됩니다.   

---

#### 나의 풀이

~~~python
from collections import deque

n, k = map(int, input().split())
# 출발점이 도착점 보다 크다면 예외처리 후 종료
if n >= k:
    print(n-k)
    print(1)
    exit(0)

answer = []
dp = [0] * 100001
que = deque([(n, 0)])
# bfs 실행
while que:
    cur, sec = que.popleft()
    dp[cur] = sec
    # 모든 경우에서 3가지 선택을 확인
    for next in [cur + 1, cur - 1, cur * 2]:
        # 확인해야 하는 범위를 벗어나는 경우 생략
        if next < 0 or next > 100000 or dp[next]:
            continue
        # 결과 리스트가 있다면 저장된 값보다 다음에 올 값이 크다면 생략
        if answer and answer[0] < sec + 1:
            continue
        # 다음에 확인할 번호를 que에 push
        que.append((next, sec + 1))
        # 정답에 도달한 개수를 알아야 하기 때문에 도달할 때마다 결과 리스트에 저장
        if next == k:
            answer.append(sec + 1)
# 가장 빨리 도착한 시간을 출력
print(answer[0])
# 가장 빨리 도착한 경로의 개수를 출력
print(len(answer))
~~~
