# 소형기관차 (Gold 4)

### 문제

기차는 맨 앞에 있는 기관차 1대가 손님이 탄 객차 여러 칸을 끌고 간다. 기관차가 고장나면 기차를 운행할 수 없게 되므로 최근 철도청은 기관차 고장에 대비하여 몇몇 역에 소형 기관차 3대를 배치하기로 결정하였다. 소형 기관차는 평소에 이용하는 기관차보다 훨씬 적은 수의 객차만을 끌 수 있다.   

기관차가 고장났을 때 끌고 가던 객차 모두를 소형 기관차 3대가 나누어 끌 수 없기 때문에, 소형 기관차들이 어떤 객차들을 끌고 가는 것이 좋을까하는 문제를 고민하다가 다음과 같이 하기로 결정하였다.   

1. 소형 기관차가 최대로 끌 수 있는 객차의 수를 미리 정해 놓고, 그보다 많은 수의 객차를 절대로 끌게 하지 않는다. 3대의 소형 기관차가 최대로 끌 수 있는 객차의 수는 서로 같다.

2. 소형 기관차 3대를 이용하여 최대한 많은 손님을 목적지까지 운송하도록 한다. 각 객차 마다 타고 있는 손님의 수는 미리 알고 있고, 다른 객차로 손님들이 이동하는 것은 허용하지 않는다.

3. 각 소형 기관차는 번호가 연속적으로 이어진 객차를 끌게 한다. 객차는 기관차 바로 뒤에 있는 객차부터 시작하여 1번 부터 차례로 번호가 붙어있다.

예를 들어 기관차가 끌고 가던 객차가 7칸이고, 소형 기관차 1대가 최대로 끌 수 있는 객차 수는 2칸이라고 하자. 그리고 1번 부터 7번까지 각 객차에 타고 있는 손님의 수가 아래 표와 같다고 하자. 괄호속에 있는 숫자는 객차 번호를 나타낸다.   

|(1)|	(2)|	(3)|	(4)|	(5)|	(6)|	(7)|
|-|-|-|-|-|-|-|
|35|	40|	50|	10|	30|	45|	60|

소형 기관차 3대는 각각 1-2번, 3-4번, 그리고 6-7번 객차를 끌고 가면 손님 240명을 운송할 수 있고, 이보다 많은 수의 손님을 운송할 수 없다.   

기관차가 끌고 가던 객차의 수와 각 객차에 타고 있던 손님의 수, 그리고 소형 기관차가 최대로 끌수 있는 객차의 수가 주어질 때, 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 구하는 프로그램을 작성하시오.   

---

#### 입력

첫째 줄에 기관차가 끌고 가던 객차의 수가 입력된다. 그 수는 50,000 이하이다. 둘째 줄에는 기관차가 끌고 가던 객차에 타고 있는 손님의 수가 1번 객차부터 차례로 입력된다. 한 객차에 타고 있는 손님의 수는 100명 이하이고, 입력되는 숫자들 사이에 빈칸이 하나씩 있다. 셋째 줄에는 소형 기관차가 최대로 끌 수 있는 객차의 수가 입력된다. 그 수는 기관차가 끌고 가던 객차 수의 1/3보다 적다.

---

#### 출력

한 줄에 소형 기관차 3대를 이용하여 최대로 운송할 수 있는 손님 수를 출력한다.

---

#### 예제 입력 1
~~~
7
35 40 50 10 30 45 60
2
~~~

#### 예제 출력 1
~~~
240
~~~

[출처](https://www.acmicpc.net/problem/2616)

---

### 문제풀이

이번 문제는 prefix sum + Dynamic Programming 문제입니다.   

소형기관차의 개수가 3개로 고정됐기 때문에 3번을 선택할 수 있고, dp 테이블도 3개로 만들 수 있습니다.   

dp 테이블을 2차원으로 구성하고, 테이블의 행은 선택의 횟수를 나타내고, 열은 손님의 수를 나타냅니다.   

dp\[i]\[M]의 의미는 i번째 소형 기관차까지 선택했을 때의 손님의 최대수입니다.   

dp 테이블과 구간 합배열을 이용해 소형 기관차에 태울 수 있는 손님의 수를 계속 갱신해주면 문제를 해결할 수 있습니다.   

문제를 다 풀고 보니 저는 구간 합 알고리즘을 제대로 사용하지 못했습니다.   

아래의 출처를 보면 글쓴이 분이 제대로 설명해주셨기 때문에 출처를 같이 첨부합니다.   

---

#### 나의 풀이

~~~python
n = int(input())
trains = list(map(int, input().split()))
m = int(input())
dp = [[0] * n for i in range(4)]

ps = [0] * n
for i in range(n-m+1):
    ps[i+m-1] = sum(trains[i:i+m])

for i in range(1, 4):
    for j in range((m*i)-1, n):
        dp[i][j] = max(ps[j] + dp[i-1][j-m], dp[i][j-1])

print(dp[3][n-1])
~~~

---

#### 다른 사람의 풀이

출처 : https://velog.io/@kimdukbae/BOJ-2616-%EC%86%8C%ED%98%95%EA%B8%B0%EA%B4%80%EC%B0%A8-Python

~~~python
import sys

input = sys.stdin.readline
N = int(input())
train = list(map(int, input().split()))
limit = int(input())

# 구간합 계산
S = [0]
value = 0
for t in train:
    value += t
    S.append(value)

dp = [[0] * (N + 1) for _ in range(4)]

# 점화식을 이용해 최댓값 탐색
for n in range(1, 4):
    for m in range(n * limit, N + 1):
        # n = 1일 때 선택한 객차가 없으므로
        # 전에 계산한 구간합과 현재 계산하는 구간합 중 최댓값을 계산해 갱신해준다.
        if n == 1:
            dp[n][m] = max(dp[n][m - 1], S[m] - S[m - limit])

        # 점화식
        else:
            dp[n][m] = max(dp[n][m - 1], dp[n - 1][m - limit] + S[m] - S[m - limit])
        # print_dp(dp)

print(dp[3][N])
~~~
