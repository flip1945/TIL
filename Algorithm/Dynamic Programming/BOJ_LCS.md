# LCS (Gold 5)

### 문제

LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다.   

예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다.

---

#### 입력

첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다.

---

#### 출력

첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.

---

#### 예제 입력 1
~~~
ACAYKP
CAPCAK
~~~

#### 예제 출력 1
~~~
4
~~~

[출처](https://www.acmicpc.net/problem/9251)

---

### 문제풀이

이 문제는 Dynamic Programming 알고리즘으로 풀어야 하는 문제입니다.   

저는 dp 문제를 여러번 풀어서 꽤 익숙해진 줄 알았는데, 아직도 많이 부족한 것 같습니다.   

dp 문제는 유형이 다양하고 푸는 방식이 제각각이라서 더 많은 문제를 풀어야 겠다는 생각이 들었습니다.   

이 문제를 처음 봤을 때, 푸는 방법이 도저히 떠오르지 않아서 다른 사람의 풀이를 봤습니다.   

아래에 설명을 정말 잘 하신 분의 풀이가 있어서 첨부했습니다.   

이 문제를 푸는 방법은 다음과 같습니다.

1. 입력받은 문자열 2개를 기준으로 dp 테이블을 생성한다.

2. 모든 행렬을 확인하면서 같은 행렬의 문자열이 일치하는지 확인한다.

3. 일치하는 경우 현재 행렬의 dp 테이블 값을 이전 dp 테이블(현재 행, 열 보다 1씩 작은 dp 테이블에 저장된 값)값에 1 증가 시킨 값으로 갱신 시킨다.

4. 일치하지 않는 경우 바로 이전 dp 테이블(현재 행보다 1작은, 현재 열보다 1작은 dp 테이블에 저장된 값) 중 큰 값으로 갱신 시킨다.

위 과정을 반복하면 마지막 행에는 가장 긴 부분 문자의 길이가 저장됩니다.

---

#### 나의 풀이

~~~python
s1 = input()
s2 = input()

dp = [[0] * (len(s2)+1) for _ in range(len(s1)+1)]

for i in range(1, len(s1)+1):
    for j in range(1, len(s2)+1):
        if s1[i-1] == s2[j-1]:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(max(dp[-1]))
~~~

---

#### 다른 사람의 풀이

출처 : https://velog.io/@emplam27/%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-%EA%B7%B8%EB%A6%BC%EC%9C%BC%EB%A1%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EB%8A%94-LCS-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98-Longest-Common-Substring%EC%99%80-Longest-Common-Subsequence
