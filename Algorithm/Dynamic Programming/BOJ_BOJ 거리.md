# 점프(Silver 2)

### 문제

BOJ 거리는 보도블록 N개가 일렬로 놓여진 형태의 도로이다. 도로의 보도블록은 1번부터 N번까지 번호가 매겨져 있다.   

스타트의 집은 1번에 있고, 링크의 집은 N번에 있다. 스타트는 링크를 만나기 위해서 점프해가려고 한다.   

BOJ거리의 각 보도블록에는 B, O, J 중에 하나가 쓰여 있다. 1번은 반드시 B이다.   

스타트는 점프를 통해서 다른 보도블록으로 이동할 수 있다. 이때, 항상 번호가 증가하는 방향으로 점프를 해야 한다. 만약, 스타트가 현재 있는 곳이 i번이라면, i+1번부터 N번까지로 점프를 할 수 있다. 한 번 k칸 만큼 점프를 하는데 필요한 에너지의 양은 k\*k이다.   

스타트는 BOJ를 외치면서 링크를 만나러 가려고 한다. 따라서, 스타트는 B, O, J, B, O, J, B, O, J, ... 순서로 보도블록을 밟으면서 점프를 할 것이다.   

스타트가 링크를 만나는데 필요한 에너지 양의 최솟값을 구하는 프로그램을 작성하시오.   

---

#### 입력

첫째 줄에 1 ≤ N ≤ 1,000이 주어진다.   

둘째 줄에는 보도블록에 쓰여 있는 글자가 1번부터 순서대로 주어진다.   

---

#### 출력

스타트가 링크를 만나는데 필요한 에너지 양의 최솟값을 출력한다. 만약, 스타트가 링크를 만날 수 없는 경우에는 -1을 출력한다.   

---

#### 예제 입력 1
~~~
9
BOJBOJBOJ
~~~

#### 예제 출력 1
~~~
8
~~~

#### 예제 입력 1
~~~
9
BOJBOJBOJ
~~~

#### 예제 출력 1
~~~
8
~~~

#### 예제 입력 2
~~~
8
BJJOOOBB
~~~

#### 예제 출력 2
~~~
-1
~~~

#### 예제 입력 3
~~~
13
BJBBJOOOJJJJB
~~~

#### 예제 출력 3
~~~
50
~~~

#### 예제 입력 4
~~~
2
BO
~~~

#### 예제 출력 4
~~~
1
~~~

#### 예제 입력 5
~~~
15
BJBOJOJOOJOBOOO
~~~

#### 예제 출력 5
~~~
52
~~~

[출처](https://www.acmicpc.net/problem/12026)

---

### 문제풀이

이번 문제는 완전 탐색 + Dynamic Programming 문제입니다.   

제가 문제를 해결한 방식은 다음과 같습니다.

1. 모든 문자열을 확인하는데, 현재 문자열에서 다음에 점프할 수 있는 문자열인 곳만 갱신해줍니다.
2. 각각의 위치에서 현재 위치에 저장된 값보다 작은 값이 올 경우만 갱신해 줍니다.
3. 모든 문자열을 다 확인하면 최종적으로 목적지에 저장된 값이 가장 작은 값이 됩니다.
4. 이렇게 하면 O(n^2) 시간에 문제를 해결할 수 있는데, n값이 1,000 이므로 이 방법으로 충분히 해결 가능합니다.

Dynamic Programming 방식으로 해결해야 한다는 생각을 떠올리면 쉬운 문제인데, 저는 이미 Dynamic Programming으로 분류된 문제 풀면서 이 문제를 만났기 때문에 쉽게 푼 것 같습니다.

---

#### 나의 풀이

~~~python
n = int(input())
s = input()

INF = int(10e9)

BOJ = {"B": 0, "O": 1, "J": 2}
dp = [INF] * n
dp[0] = 0
# 모든 문자열을 탐색
for i in range(n):
    # 다음에 올 BOJ 값을 설정
    next_boj = BOJ[s[i]] + 1 if s[i] != "J" else 0
    # 현재 문자열보다 뒤에 있는 문자열을 탐색
    for j in range(i+1, n):
        # 다음에 올 문자열인 경우만 값을 갱신
        if BOJ[s[j]] == next_boj:
            # 현재 저장된 값보다 작은 경우만 갱신
            dp[j] = min(dp[j], dp[i] + (j-i)**2)
# 목적지에 저장된 값이 초기 설정된 값이 아닌 경우 그대로 출력
# 목적지에 저장된 값이 초기 설정된 값인 경우 목적지에 도달 불가능하므로 -1을 출력
print(dp[-1] if dp[-1] != INF else -1)
~~~
