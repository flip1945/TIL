# 알약 (Gold 5)

### 문제

70세 박종수 할아버지는 매일 매일 약 반알을 먹는다. 손녀 선영이는 종수 할아버지에게 약이 N개 담긴 병을 선물로 주었다.

첫째 날에 종수는 병에서 약 하나를 꺼낸다. 그 다음, 그 약을 반으로 쪼개서 한 조각은 먹고, 다른 조각은 다시 병에 넣는다.

다음 날부터 종수는 병에서 약을 하나 꺼낸다. (약은 한 조각 전체 일 수도 있고, 쪼갠 반 조각 일 수도 있다) 반 조각이라면 그 약을 먹고, 아니라면 반을 쪼개서 한 조각을 먹고, 다른 조각은 다시 병에 넣는다.

종수는 손녀에게 한 조각을 꺼낸 날에는 W를, 반 조각을 꺼낸 날에는 H 보낸다. 손녀는 할아버지에게 받은 문자를 종이에 기록해 놓는다. 총 2N일이 지나면 길이가 2N인 문자열이 만들어지게 된다. 이때, 가능한 서로 다른 문자열의 개수는 총 몇 개일까?

---

#### 입력

입력은 최대 1000개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄이며, 병에 들어있는 약의 개수 N ≤ 30 가 주어진다.

입력의 마지막 줄에는 0이 하나 주어진다.

---

#### 출력

각 테스트 케이스에 대해서 가능한 문자열의 개수를 출력한다.

출처 : https://www.acmicpc.net/problem/20159

---

### 문제풀이

이번 문제는 dp 문제입니다.

예제 출력의 숫자를 보고 dp 문제임을 짐작했지만 1차원 dp라고만 생각해서 문제를 해결할 수 없었습니다.

너무 어려운 거 같아서 다른 분들의 풀이를 참고했는데 핵심은 2차원 dp로 바꿔서 풀이하는 것이었습니다.

W와 H를 세로축, 가로축으로 잡고 W, H의 경우의 수를 표에 기입하면서 풀면 쉽게 문제를 해결할 수 있었습니다.

이 문제를 풀면서 역시 dp 문제는 어렵다는 생각이 들었고 풀이가 떠오르지 않을 때는 다차원 dp로 문제를 해결할 수 있는지 살펴봐야 겠습니다.

---

#### 나의 풀이

~~~python
dp = [[0] * 32 for _ in range(32)]
dp[1] = [i for i in range(32)]

for i in range(1, 31):
    for j in range(i, 31):
        dp[i+1][j] += dp[i][j]
        if i != 1:
            dp[i][j+1] += dp[i][j]

n = int(input())
while n:
    print(dp[n][n])
    n = int(input())
~~~
