# 가장 긴 증가하는 부분 수열 (Silver 2)

### 문제

수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열을 구하는 프로그램을 작성하시오.   

예를 들어, 수열 A = {10, 20, 10, 30, 20, 50} 인 경우에 가장 긴 증가하는 부분 수열은 A = {10, 20, 10, 30, 20, 50} 이고, 길이는 4이다.

---

#### 입력

첫째 줄에 수열 A의 크기 N (1 ≤ N ≤ 1,000)이 주어진다.   

둘째 줄에는 수열 A를 이루고 있는 Ai가 주어진다. (1 ≤ Ai ≤ 1,000)

---

#### 출력

첫째 줄에 수열 A의 가장 긴 증가하는 부분 수열의 길이를 출력한다.

---

#### 예제 입력 1
~~~
6
10 20 10 30 20 50
~~~

#### 예제 출력 1
~~~
4
~~~

[출처](https://www.acmicpc.net/problem/11053)

---

### 문제풀이

이 문제는 Dynamic Programming 알고리즘 문제입니다.   

가장 긴 증가하는 부분 수열을 구하는 문제로 입력의 크기가 1000 이하이기 때문에 비교적 쉽게 문제를 해결할 수 있었습니다.   

O(n^2) 정도의 시간 복잡도를 가지는 알고리즘으로 문제를 풀 수 있기 때문에 그렇게 문제를 풀었습니다.

1. dp 테이블로 모든 수열의 부분 수열의 최대 값을 저장하는 리스트를 생성합니다.
2. 모든 수열을 반복하면서 현재 확인하고 있는 수열 보다 이전 수열에서 저장된 가장 큰 값을 dp테이블에 저장합니다.
3. 단, 현재 확인하고 있는 수열보다 크기가 작은 수열만 확인합니다.(크기가 큰 수열은 증가하는 수열이라고 볼 수 없으므로)

---

#### 나의 풀이

~~~python
n = int(input())
nums = list(map(int, input().split()))
dp = [0] * n

# 모든 수열을 반복하면서 확인
for i in range(n):
    # 이전 수열 중에 현재 수열의 값보다 작은 수열 중에서 가장 큰 값을 확인
    # (+ [0]은 빈리스트가 생성될 때를 위한 예외처리 부분)
    dp[i] = max([dp[j] for j in range(i) if nums[j] < nums[i]] + [0]) + 1

print(max(dp))
~~~

---

#### 다른 사람의 풀이

~~~python
N = int(input())

arr = list(map(int,input().split()))
dp = [0]*1001
for i in range(N):
    dp[arr[i]] = max(dp[:arr[i]]) + 1
    
print(max(dp))
~~~
