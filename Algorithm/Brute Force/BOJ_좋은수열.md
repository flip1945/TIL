# 좋은수열 (Gold 4)

### 문제 설명

숫자 1, 2, 3으로만 이루어지는 수열이 있다. 임의의 길이의 인접한 두 개의 부분 수열이 동일한 것이 있으면, 그 수열을 나쁜 수열이라고 부른다. 그렇지 않은 수열은 좋은 수열이다.   

다음은 나쁜 수열의 예이다.   

* 33

* 32121323

* 123123213

다음은 좋은 수열의 예이다.   

* 2

* 32

* 32123

* 1232123

길이가 N인 좋은 수열들을 N자리의 정수로 보아 그중 가장 작은 수를 나타내는 수열을 구하는 프로그램을 작성하라. 예를 들면, 1213121과 2123212는 모두 좋은 수열이지만 그 중에서 작은 수를 나타내는 수열은 1213121이다.   

---

#### 입력

입력은 숫자 N하나로 이루어진다. N은 1 이상 80 이하이다.       

---

#### 출력

첫 번째 줄에 1, 2, 3으로만 이루어져 있는 길이가 N인 좋은 수열들 중에서 가장 작은 수를 나타내는 수열만 출력한다. 수열을 이루는 1, 2, 3들 사이에는 빈칸을 두지 않는다.

---
#### 예제 입력 1

~~~
7
~~~

#### 예제 출력 1

~~~
1213121
~~~

출처 : https://www.acmicpc.net/problem/2661

---

### 문제풀이

이번 문제는 전형적인 백트래킹 문제입니다.   

만약 이 문제를 풀기 위해서 모든 경우의 수를 다 따지게 되면 O(3^n)이 시간이 필요합니다.   

n의 최대값은 80이므로 제 시간안에 계산하는 것이 불가능합니다.   

그래서 백트래킹을 사용해 더 확인할 필요가 없는 경우는 더이상 확인하지 않고,   

정답이 될 수 있는 경우만 빠르게 탐색합니다.   

그리고 가장 빨리 나온 결과를 제출하면 그게 정답인 가장 작은 수열이 됩니다.   

---

#### 나의 풀이

~~~python
N = int(input())

def is_bad_nums(arr):
    n = len(arr)
    for i in range(1, n // 2 + 1):
        if arr[n-i*2:n-i] == arr[n-i:n]:
            return True
    return False

def recursive(arr):
    if len(arr) == N + 1:
        print("".join(arr[:-1]))
        exit(0)

    if is_bad_nums(arr):
        return

    for i in range(1, 4):
        arr.append(str(i))
        recursive(arr)
        arr.pop()

recursive([])
~~~

---

#### 다른 사람의 풀이

출처 : https://www.acmicpc.net/source/27306511

~~~python
import sys

def dfs(s, c):
    for i in range(1, c//2+1):
        if s[-i:] == s[-2*i:-i]:
            return
    if c == n:
        print(s)
        sys.exit()

    for i in ['1', '2', '3']:
        dfs(s+i, c+1)

n = int(input())
dfs('1', 1)
~~~
