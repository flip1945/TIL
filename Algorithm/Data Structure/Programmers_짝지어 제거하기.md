# 짝지어 제거하기(Level 2)

### 문제 설명

짝지어 제거하기는, 알파벳 소문자로 이루어진 문자열을 가지고 시작합니다. 먼저 문자열에서 같은 알파벳이 2개 붙어 있는 짝을 찾습니다. 그다음, 그 둘을 제거한 뒤, 앞뒤로 문자열을 이어 붙입니다. 이 과정을 반복해서 문자열을 모두 제거한다면 짝지어 제거하기가 종료됩니다. 문자열 S가 주어졌을 때, 짝지어 제거하기를 성공적으로 수행할 수 있는지 반환하는 함수를 완성해 주세요. 성공적으로 수행할 수 있으면 1을, 아닐 경우 0을 리턴해주면 됩니다.

예를 들어, 문자열 S = `baabaa` 라면   

b aa baa → bb aa → aa →   

의 순서로 문자열을 모두 제거할 수 있으므로 1을 반환합니다.   

---

#### 제한사항

* 문자열의 길이 : 1,000,000이하의 자연수

* 문자열은 모두 소문자로 이루어져 있습니다.

---

#### 입출력 예

|s|	result|
|-|-|
|baabaa|	1|
|cdcd|	0|

#### 입출력 예 설명

##### 입출력 예 #1

위의 예시와 같습니다.

##### 입출력 예 #2

문자열이 남아있지만 짝지어 제거할 수 있는 문자열이 더 이상 존재하지 않기 때문에 0을 반환합니다.

[출처](https://programmers.co.kr/learn/courses/30/lessons/12973)

---

### 문제풀이

이 문제는 stack을 활용하면 쉽게 풀 수 있는 문제입니다.   

stack을 사용하는 기초 문제라고 생각합니다.   

풀이 방법은 stack을 생성하고, 모든 문자열을 확인하면서 stack에 push, pop 하면 됩니다.   

stack에 문자를 저장하고 다음에 오는 문자가 같다면 stack에서 pop하고, 아니라면 스택에 push하면 됩니다.   

그러면 짝지어 제거할 수 있는 문자열은 stack이 비어 있을 것이고, 아닌 문자열은 지워지지 않고 stack에 남아 있기 때문에 이를 결과로 반환해주면 됩니다.

그렇게하면 O(n)의 시간에 해결할 수 있습니다.   

---

#### 나의 풀이

~~~python
def solution(s):
    stack = []
    for i in s:
        # stack이 있고, 현재 문자와 top이 같은 문자라면
        if stack and i == stack[-1]:
            # stack에서 pop
            stack.pop()
        # 현재 문자와 top이 같은 문자가 아니라면
        else:
            # stack에 push
            stack.append(i)
    # stack에 값이 있다면 짝지어 제거할 수 없는 문자열이고, stack에 값이 없다면 지울 수 있는 문자열입니다.
    return 0 if stack else 1
~~~
