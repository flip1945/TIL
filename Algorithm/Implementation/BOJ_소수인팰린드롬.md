# 소수인팰린드롬 (Gold 5)

### 문제

151은 소수이면서 동시에 팰린드롬이기 때문에 소수인 팰린드롬이다. 팰린드롬이란 앞으로 읽어나 뒤로 읽으나 같은 수를 말한다. 예를 들어 1234는 앞으로 읽으면 1234지만, 뒤로 읽으면 4321이 되고 이 두 수가 다르기 때문에 팰린드롬이 아니다. 두 정수 a, b가 주어졌을 때, a이상 b이하인 소수인 팰린드롬을 모두 구하는 프로그램을 작성하시오.

---

#### 입력

입력은 첫째 줄에 공백으로 구분된 두 자연수 a, b가 주어진다. 단 5 ≤ a < b ≤ 100,000,000 이다.

---

#### 출력

첫째 줄부터 차례로 증가하는 순서대로 한 줄에 한개씩 소수인 팰린드롬을 출력한다. 마지막 줄에는 -1을 출력한다.

출처 : https://www.acmicpc.net/problem/1990

---

### 문제풀이

이번 문제는 펠린드롬 문제입니다.

1억 미만인 소수 중에서 팰린드롬인 수를 출력해야 하는 문제입니다.

숫자의 크기가 최대 1억이기 때문에 바로 에라토스테네스의 체를 만들게 되면 메모리 초과가 나게 됩니다.

그렇다고 범위 안에 있는 모든 숫자를 소수인지 확인하게 되면 시간초과에 빠지게 됩니다.

그래서 다른 풀이가 필요하다고 생각했고, 미리 팰린드롬인 숫자를 구한 뒤 그 숫자들만을 대상으로 소수 판별을 하는 풀이를 떠올렸습니다.

1억 미만의 팰린드롬 숫자를 모두 구해봤는데 2만개 정도밖에 안 돼서 생각한 풀이를 사용해 문제를 해결할 수 있었습니다.

문제를 푼 후 다른 풀이를 찾아봤는데 길이가 짝수인 팰린드롬은 모두 11의 배수(짝수 자리의 숫자의 합 - 홀수 자리 숫자의 합 = 0을 만족하는 수)이기 때문에 최대 10,000,000인 숫자에 대해서 에라토스테네스의 체를 이용해 문제를 해결할 수 있다는 것을 알게됐습니다.

---

#### 나의 풀이

~~~python
a, b = map(int, input().split())

def is_prime(num):
    for n in range(2, int(num**.5) + 1):
        if not num % n:
            return False
    return True

palindrome = [[] for _ in range(9)]
palindrome[0] = [""]
palindrome[1] = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]
for i in range(2, 9):
    for j in "0123456789":
        for k in palindrome[i-2]:
            palindrome[i].append(j + k + j)

palindrome[1] = ["5", "7"]
for i in range(1, 9):
    for p in palindrome[i]:
        if a <= int(p) <= b and is_prime(int(p)):
            print(p)
print(-1)
~~~

#### 다른 사람의 풀이

https://kth990303.tistory.com/184
