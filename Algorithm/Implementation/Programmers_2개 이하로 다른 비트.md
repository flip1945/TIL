# 2개 이하로 다른 비트(Level 2)

### 문제 설명

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.   

* x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수

예를 들어,   

* f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.

|수|	비트|	다른 비트의 개수|
|-|-|-|
|2|	000...0010|	|
|3|	000...0011|	1|

* f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.

|수|	비트|	다른 비트의 개수|
|-|-|-|
|7|	000...0111|	|
|8|	000...1000|	4|
|9|	000...1001|	3|
|10|	000...1010|	3|
|11|	000...1011|	2|

정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.   

---

#### 제한사항

* 1 ≤ numbers의 길이 ≤ 100,000

* 0 ≤ numbers의 모든 수 ≤ 10^15

---

#### 입출력 예

|numbers|	result|
|-|-|
|\[2,7]|	\[3,11]|

#### 입출력 예 설명

##### 입출력 예 #1

* 문제 예시와 같습니다.

[출처](https://programmers.co.kr/learn/courses/30/lessons/77885)

---

### 문제풀이

이 문제는 비트 연산으로 정답을 찾는 문제입니다.    

풀 수 있는 가장 간단한 방법으로 문제를 풀었는데, 시간 초과 판정을 받아서 통과하지 못했습니다.   

사용한 방법은 XOR를 사용해서 현재 숫자보다 비트수가 2개 이하로 다른 비트가 나올때까지 반복하도록 했습니다.   

1개의 숫자를 가지고 정답을 찾는 문제였다면 통과했겠지만 배열의 길이가 10만개 이하이기 때문에 시간 초과할 수 밖에 없었다고 생각합니다.   

그래서 다른 방법으로 풀게 됐는데, 저는 홀수와 짝수를 나눠서 생각해봤습니다.   

2진수의 특성상 짝수는 가장 작은 비트가 무조건 0입니다.   

즉, 짝수인 경우 값에 +1을 해주기만 하면 비트 수가 1개 다르기 때문에 정답을 바로 구할 수 있습니다.   

홀수인 경우는 조건을 더 생각해봤습니다.   

현재 수보다 크고 비트 수의 차이가 2개 이하인 경우는 2가지 경우 밖에 없습니다.   

비트 수의 차이가 1개이거나 2개인 경우입니다.   

말장난 같겠지만 이 말 속에는 문제를 풀 수 있는 핵심이 존재합니다.   

아까 짝수인 경우는 현재 수에서 1을 더하면 된다고 했습니다.   
즉, 어떤 짝수이던 간에 비트 수의 차이는 1개입니다.   

그럼 홀수인 경우를 알아봐야 합니다.   
홀수는 가장 작은 비트의 숫자가 1이기 때문에 1을 더하면 달라지는 비트의 수가 최소 2개입니다.   

물론 달라지는 비트의 수가 1개 경우도 있지만 이런 경우는 값이 커지기 때문에 조건을 만족하는 최소값이 될 수 없습니다.   

즉, 홀수일 경우 조건을 만족하는 가장 작은 수는 비트 수의 차이가 2일 때 뿐입니다.   

아래는 몇 가지 홀수 예시입니다.   

11101 -> 11110   

10101 -> 10110   

01111 -> 10111   

위의 홀수 예시에서 비트 수의 차이가 2개인 경우를 만족하려면 0과 1의 자리를 바꿔야합니다.   

그 중 조건을 만족하는 가장 작은 수는 가장 작은 비트의 0과 바로 오른쪽의 1을 서로 바꾼 수입니다.   

저는 이 로직으로 문제를 풀어서 통과하게 됐습니다.   

---

#### 나의 풀이

~~~python
def solution(numbers):
    answer = []
    
    for num in numbers:
        # 홀수일 경우
        if int(num) % 2:
            num = ["0"] + list(bin(num)[2:])
            # 가장 오른쪽부터 탐색
            for i in range(len(num)-1,-1,-1):
                # 홀수의 경우, 0 중에 가장 작은 0과 바로 오른쪽의 1을 바꾸면 됨
                if num[i] == "0":
                    num[i], num[i+1] = "1", "0"
                    answer.append(int("".join(num), 2))
                    break

        # 짝수일 경우 현재 숫자에 1을 더함
        else:
            answer.append(num + 1)
    return answer
~~~
